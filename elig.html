<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Eligibility Checker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Main styles moved to tables.css -->
  <link rel="stylesheet" href="tables.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="elig.js"></script>
</head>
<body>
  <div class="app">
    <div class="app-header">
      <!-- header area is intentionally minimal -->
    </div>

    <div class="app-content">
      <aside class="sidebar" id="sidebar">
        <h1 class="page-title">Eligibility Checker</h1>

        <!-- Explanation Box -->
        <div id="explanation" class="mb-3">
          <b>Welcome!</b> This is a simple tool for checking patient eligibility.
          <ul class="mb-0 mt-2">
            <li><b>1.</b> Upload your patient report (Clinicpro, Odoo, or InstaHMS).</li>
            <li><b>2.</b> Upload the Eligibility XLSX file.</li>
            <li><b>3.</b> Click <b>Process</b> to check eligibility.</li>
            <li><b>4.</b> Click <b>Export Invalid Rows</b> to download patients not eligible.</li>
          </ul>
        </div>

        <form>
          <div class="file-upload-area mb-3">
            <div class="mb-3">
              <label for="reportFileInput" class="form-label">Upload Patient Report (Clinicpro, Odoo, or InstaHMS):</label>
              <div class="input-group">
                <span class="input-group-text"><i class="bi bi-file-earmark-excel"></i></span>
                <input type="file" class="form-control" id="reportFileInput" multiple accept=".xls,.xlsx,.csv">
              </div>
            </div>
            <div class="mb-3">
              <label for="eligibilityFileInput" class="form-label">Upload Eligibility XLSX:</label>
              <div class="input-group">
                <span class="input-group-text"><i class="bi bi-file-earmark-spreadsheet"></i></span>
                <input type="file" class="form-control" id="eligibilityFileInput" accept=".xlsx">
              </div>
            </div>
          </div>

          <!-- Daman/Thiqa Filter Toggle -->
          <div class="filter-toggle-area">
            <label class="form-check-label">
              <input class="form-check-input me-2" type="checkbox" id="filterDamanThiqa">
              Show only <b>Daman / Thiqa</b> claims
            </label>
            <span id="filterStatus" class="filter-status">OFF</span>
          </div>

          <div class="d-flex gap-2 mb-2 justify-content-start">
            <button type="button" id="processBtn" class="btn btn-primary" disabled>
              <i class="bi bi-play-fill"></i> Process
            </button>
            <button type="button" id="exportInvalidBtn" class="btn btn-secondary" disabled>
              <i class="bi bi-arrow-down-circle"></i> Export Invalid Rows
            </button>
          </div>
          <div id="uploadStatus" class="mt-2 text-primary fs-6"></div>
        </form>

        <div style="height:18px;"></div>
        <div style="font-size:0.9rem; color:#58616a;">
          Tip: Results appear on the right. If the table is long you can scroll it independently; a subtle fade will appear at the bottom to indicate more content.
        </div>
      </aside>

      <!-- resizer handle between columns -->
      <div id="dragHandle" class="drag-handle" role="separator" aria-orientation="vertical" tabindex="0" aria-label="Resize sidebar"></div>

      <main class="main" id="mainPanel">
        <div class="results-header">
          <div class="results-title">Results</div>

          <!-- Result-window-only filters (invalid-only default checked) -->
          <div class="d-flex align-items-center gap-2">
            <div class="form-check form-switch mb-0">
              <input class="form-check-input" type="checkbox" id="filterInvalidOnly" checked>
              <label class="form-check-label small" for="filterInvalidOnly">Invalid only</label>
            </div>
            <div style="font-size:0.9rem; color:#6c757d;">Table output and export actions</div>
          </div>
        </div>

        <!-- This is the scrollable area where generated table(s) will be placed -->
        <div id="results" aria-live="polite">
          <!-- Existing behavior: elig.js should populate this #results element with the generated table -->
          <div class="text-muted">No results yet. Upload files and click Process.</div>
          <div class="results-footer-space"></div>
        </div>

        <!-- Fade overlay shown only when #results can be scrolled down -->
        <div class="fade-overlay" id="resultsFade"></div>
      </main>
    </div>
  </div>

  <!-- Bootstrap Icons CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <script src="table_clipboard.js"></script>

  <script>
    // Resizable sidebar implementation using Pointer Events for reliable dragging (mouse/touch/stylus).
    (function () {
      const handle = document.getElementById('dragHandle');
      const sidebar = document.getElementById('sidebar');
      const container = document.querySelector('.app-content');
      const STORAGE_KEY = 'elig_sidebar_width';

      if (!handle || !sidebar || !container) return;

      // Minimum and maximum sizes (in px / pct)
      const MIN_WIDTH = 220;
      const MAX_WIDTH_PCT = 0.75; // max 75% of container width
      let dragging = false;
      let startClientX = 0;
      let startWidth = 0;
      let pointerId = null;

      // Initialize from persisted width if available
      function applyStored() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return;
          const px = parseInt(raw, 10);
          if (isNaN(px)) return;
          const maxAllowed = Math.floor(container.clientWidth * MAX_WIDTH_PCT);
          const widthToSet = Math.min(Math.max(px, MIN_WIDTH), maxAllowed);
          sidebar.style.flex = `0 0 ${widthToSet}px`;
          sidebar.style.width = `${widthToSet}px`;
        } catch (e) { /* ignore storage errors */ }
      }
      applyStored();

      function startDrag(e) {
        // Accept pointerdown only (mouse/touch/stylus)
        if (dragging) return;
        dragging = true;
        // For pointer events, store pointerId to release capture later
        pointerId = e.pointerId || null;
        startClientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
        startWidth = sidebar.getBoundingClientRect().width;

        // Freeze text selection & set dragging cursor
        document.body.style.userSelect = 'none';
        document.documentElement.classList.add('dragging');

        // Use pointer capture if available (improves reliability)
        try { if (pointerId && handle.setPointerCapture) handle.setPointerCapture(pointerId); } catch (err) {}

        window.addEventListener('pointermove', onDrag);
        window.addEventListener('pointerup', endDrag);
        window.addEventListener('pointercancel', endDrag);
      }

      function onDrag(e) {
        if (!dragging) return;
        // Prevent default scrolling on touch
        if (e.cancelable) e.preventDefault();

        const clientX = e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX) || 0;
        const delta = clientX - startClientX;
        const containerRect = container.getBoundingClientRect();
        const maxAllowed = Math.floor(containerRect.width * MAX_WIDTH_PCT);
        let newWidth = Math.round(startWidth + delta);
        newWidth = Math.max(MIN_WIDTH, Math.min(newWidth, maxAllowed));

        // Apply width as fixed flex-basis so main column shrinks/grows properly
        sidebar.style.flex = `0 0 ${newWidth}px`;
        sidebar.style.width = `${newWidth}px`;

        // Persist
        try { localStorage.setItem(STORAGE_KEY, String(newWidth)); } catch (err) {}
        // update fade overlay if needed (results area)
        if (window.__elig_updateResultsFade) window.__elig_updateResultsFade();
      }

      function endDrag(e) {
        if (!dragging) return;
        dragging = false;
        document.body.style.userSelect = '';
        document.documentElement.classList.remove('dragging');

        // release pointer capture
        try { if (pointerId && handle.releasePointerCapture) handle.releasePointerCapture(pointerId); } catch (err) {}

        window.removeEventListener('pointermove', onDrag);
        window.removeEventListener('pointerup', endDrag);
        window.removeEventListener('pointercancel', endDrag);
      }

      // Keyboard accessibility: left/right to shrink/expand
      handle.addEventListener('keydown', (ev) => {
        const step = 20;
        if (ev.key === 'ArrowLeft' || ev.key === 'Left') {
          const cur = sidebar.getBoundingClientRect().width;
          const next = Math.max(MIN_WIDTH, cur - step);
          sidebar.style.flex = `0 0 ${next}px`;
          sidebar.style.width = `${next}px`;
          try { localStorage.setItem(STORAGE_KEY, String(next)); } catch (err) {}
          ev.preventDefault();
          if (window.__elig_updateResultsFade) window.__elig_updateResultsFade();
        } else if (ev.key === 'ArrowRight' || ev.key === 'Right') {
          const containerRect = container.getBoundingClientRect();
          const maxAllowed = Math.floor(containerRect.width * MAX_WIDTH_PCT);
          const cur = sidebar.getBoundingClientRect().width;
          const next = Math.min(maxAllowed, cur + step);
          sidebar.style.flex = `0 0 ${next}px`;
          sidebar.style.width = `${next}px`;
          try { localStorage.setItem(STORAGE_KEY, String(next)); } catch (err) {}
          ev.preventDefault();
          if (window.__elig_updateResultsFade) window.__elig_updateResultsFade();
        } else if (ev.key === 'Home') {
          sidebar.style.flex = `0 0 ${MIN_WIDTH}px`;
          sidebar.style.width = `${MIN_WIDTH}px`;
          try { localStorage.setItem(STORAGE_KEY, String(MIN_WIDTH)); } catch (err) {}
          ev.preventDefault();
          if (window.__elig_updateResultsFade) window.__elig_updateResultsFade();
        } else if (ev.key === 'End') {
          const containerRect = container.getBoundingClientRect();
          const maxAllowed = Math.floor(containerRect.width * MAX_WIDTH_PCT);
          sidebar.style.flex = `0 0 ${maxAllowed}px`;
          sidebar.style.width = `${maxAllowed}px`;
          try { localStorage.setItem(STORAGE_KEY, String(maxAllowed)); } catch (err) {}
          ev.preventDefault();
          if (window.__elig_updateResultsFade) window.__elig_updateResultsFade();
        }
      });

      // Attach pointerdown (works for mouse/touch/stylus)
      handle.addEventListener('pointerdown', startDrag, { passive: false });

      // Also support mouse for older browsers as fallback
      handle.addEventListener('mousedown', (e) => {
        // Let pointerdown handle if available
        if (window.PointerEvent) return;
        startDrag(e);
      });

      // Ensure stored width stays within new constraints on resize
      window.addEventListener('resize', () => {
        const curWidth = sidebar.getBoundingClientRect().width;
        const maxAllowed = Math.floor(container.clientWidth * MAX_WIDTH_PCT);
        if (curWidth > maxAllowed) {
          const newW = Math.floor(Math.max(MIN_WIDTH, Math.min(curWidth, maxAllowed)));
          sidebar.style.flex = `0 0 ${newW}px`;
          sidebar.style.width = `${newW}px`;
          try { localStorage.setItem(STORAGE_KEY, String(newW)); } catch (err) {}
        }
      });
    })();
  </script>
</body>
</html>
